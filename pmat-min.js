let arrayOfStrings,base64Strings,_=require("lodash"),pmat={},testCases;pmat={api:{loader:function(){if(!pm.variables.get("flag_"+pm.info.iteration)){if(pm.variables.set("flag_"+pm.info.iteration,!0),0===pm.info.iteration){if(!pm.environment.values.toJSON().length){let b={name:"pmatSaveError",message:"environment is empty... we cancel as it looks no environment was selected and save is compromised..."};throw console.log(b),b}console.log("starting to Load Environment: "),testCases={},pm.variables.set("testCases",testCases),pm.globals.get("record")?testCases.record=!0:pm.globals.get("recordIni")&&(testCases.recordIni=!0);let a=pmat.engine.pmGlobalsGetJSON("delegateList");testCases.delegateList=[],a&&(_.isArray(a)?testCases.delegateList=a:-1===a.indexOf(",")?testCases.delegateList[0]=a:console.log("ERROR!!!: globals param delegateList is bad formatted. It should be JSON format. example: [\"refres\"]")),pmat.engine.newRun()}console.log("starting to Load Iteration: "+pm.info.iteration),pmat.api.getValidTestCases(),pmat.engine.newIteration()}else console.log("Iteration: "+pm.info.iteration+" was previously loaded...");pmat.api.getValidTestCases(),"test"!==pm.info.eventName||pm.variables.get("flagr_"+pm.info.requestId+pm.info.iteration)||(pm.variables.set("flagr_"+pm.info.requestId+pm.info.iteration,!0),testCases.record||testCases.recordIni?pmat.api.record():pmat.api.test())},save:function({varName:a=null,valueResponsePath:b=null,value:c=null,requestName:f=null}={}){try{return pmat.engine.save({varName:a,valueResponsePath:b,value:c,requestName:f})}catch(g){console.log("failed to execute pmat.egine.save: exception name: "+g.name+" message: "+g.message),pm.test("Critital ERROR!!!! There have been exceptions... take a look to the console logs to see them...",function(){pm.expect(0).to.equal(1)})}},record:function(){pmat.engine.record()},test:function(){pmat.engine.test()},getValidTestCases:function(){if(testCases=pm.variables.get("testCases"),!testCases)throw{name:"pmatFlowStateError",message:"testCases should have been saved as part of the initialization in newRun..."}}},util:{getValueObjDoc:"Given object and path find and return the node object in the path or null if not found",getValueObj:function(a,b){if(a===void 0||null===a||b===void 0||null===b)return null;let c=a;try{for(let f of b.split("."))if(c.hasOwnProperty(f))c=c[f];else return null;return c}catch(f){return console.log("Warning: There was an exception in getValueObj(obj, valuePath)... obj: "+a+" valuePath: "+b),null}},setValueObj:function(a,b,c){const h="CREATED",k="FAILED";let l=a,m=k,n;if(a===void 0||null===a||b===void 0||null===b)return k;try{n=b.split(".");for(let p=0,q=n.length;p<q;p++)p===n.length-1?(l.hasOwnProperty(n[p])?m!=h&&(m="MODIFIED"):m!=h&&(m="ADDED"),l[n[p]]=c):l.hasOwnProperty(n[p])?l=l[n[p]]:(l[n[p]]={},l=l[n[p]],m=h)}catch(p){return console.log("Warning: There was an exception in setValueObj(obj, valuePath, value)... obj: "+a+" valuePath: "+b+" value: "+c),m=k,m}return m},stringifyDoc:"Improve JSON.stringify() to include functions in objects",stringify:function(a,b){let f=[],g=JSON.stringify(a,function(h,k){return"function"==typeof k?(f.push(k),"____PLACEHOLDER____"):k},2);return g=g.replace(/"____PLACEHOLDER____"/g,function(){return f.shift()}),b+" = "+g+";"},isValidDateYYYYMMDDHHMMSS:function(a,b,c,f,g,h){--b;let k=new Date(a,b,c);return k.getFullYear()==a&&k.getMonth()==b&&k.getDate()==c&&0<=f&&24>f&&0<=g&&60>g&&0<=h&&60>h},isYYYYMMDDHHMMSSstr:function(a){return!!("string"==typeof a&14===a.length)&&pmat.util.isValidDateYYYYMMDDHHMMSS(parseInt(a.substr(0,4)),parseInt(a.substr(4,2)),parseInt(a.substr(6,2)),parseInt(a.substr(8,2)),parseInt(a.substr(10,2)),parseInt(a.substr(12,2)))},splitInTwo:function(a,b){let c,f=[];return c=a.indexOf(b),0===c&&(f[0]=b,f[1]=a.substring(b.length)),f},printKeysValuesDoc:"Given object find and return the node object in the path or null if not found",printKeysValues:function(a){function b(f){if(f instanceof Array)for(let g=0,h=f.length;g<h;g++)console.log(c+g+" ("+typeof f[g]+")"),"object"==typeof f[g]?(c+="-->",b(f[g]),c=c.slice(0,c.length-3)):console.log(c+": "+f[g]+" ("+typeof f[g]+")");else for(let g in f)console.log(c+g+" ("+typeof f[g]+")"),"object"==typeof f[g]?(c+="-->",b(f[g]),c=c.slice(0,c.length-3)):console.log(c+": "+f[g]+" ("+typeof f[g]+")")}let c="";b(a)},pathSearchToRegex:function(a){let b=a.split(".").join("[.]");b=b.split("*").join("[^.]*"),b=b.split("[^.]*[^.]*").join(".*"),b="^"+b+"$";let c=new RegExp(b);return c},objPropsToArray:function(a){let b=[];for(let c in a)b.push(c);return b},sleep:function(a){for(var b=new Date().getTime(),c=0;1e7>c&&!(new Date().getTime()-b>a);c++);},StopWatch:function(a){let b=0,c=0,f="initial",g=[],h=function(){"running"===f&&(c=c+Date.now()-b,b=Date.now())},k=function(r){b=0,c=0,f="initial",g=[],g[0]={elapse:0,message:r}};k(a);return{start:function(){("initial"==f||"stopped"==f)&&(b=Date.now(),f="running")},memorize:function(r){h(),g[g.length]={elapse:c,message:r}},show:function(){console.log(g)},stop:function(){h(),f="stopped"},reset:function(){k("reset")}}}},engine:{newRun:function(){let a;try{a=pmat.engine.getEnvironmentVariables("testCase_","testConditions"),pmat.engine.setTestCases(a),pmat.engine.backUpTests(),testCases.recordIni&&pmat.engine.initTestCasesRecordRelated()}catch(b){throw console.log("pmat.engine.newRun: testCases format is not correct: "+b),b}},getEnvironmentVariablesDoc:"having a list of variables names, it finds them in environment and return object with all values",getEnvironmentVariables:function(...a){const b=/^\d+$/;let c={},f=[],g,h=pm.environment.values.toJSON();if(!h)return null;for(let k=0,l=h.length;k<l;k++)if(f=pmat.engine.splitInTwoFindPrefixes(h[k].key,...a),f&&2===f.length&&"_"===f[0].slice(-1)&&f[1].match(b)){g=f[0].substring(0,f[0].length-1),c[g]||(c[g]=[]);try{c[g].push({id:f[1],value:JSON.parse(h[k].value)})}catch(m){throw console.log("Environment variable---->: "+f+" <----- it is bad formed"),console.log("With value: "+h[k].value),m}}else if(f&&2===f.length&&"_"!==f[0].slice(-1)&&""===f[1])try{c[f[0]]=JSON.parse(h[k].value)}catch(m){throw console.log("Environment variable---->: "+f+" <----- it is bad formed"),console.log("With value: "+h[k].value),m}return c},setTestCases:function(a){for(let c in a)testCases[c]=a[c];testCases.testCase||(testCases.testCase=[]),testCases.testConditions||(testCases.testConditions={}),testCases.testCase.length||console.log("Warning: No test Cases to execute. It looks like environment was not selected for the run...");let b=0;for(let c=0,f=testCases.testCase.length;c<f;c++)c>=pm.info.iterationCount?(console.log("INFO: testCase_"+testCases.testCase[c].id+" was removed as there are not enough iterations to runs..."),_.unset(testCases.testCase,c)):b++;0<b&&(testCases.testCase.length=b),testCases.index=0,testCases.initialElems=testCases.testCase.length,testCases.iteration=-1},backUpTests:function(){let a,b;if(testCases.recordIni||testCases.record){for(let c=0,f=testCases.testCase.length;c<f&&c<pm.info.iterationCount;c++)b="old_testCase_"+testCases.testCase[c].id,a="testCase_"+testCases.testCase[c].id,pm.environment.set(b,pm.environment.get(a));pm.environment.get("testConditions")&&pm.environment.set("old_testConditions",pm.environment.get("testConditions"))}},initTestCasesRecordRelated:function(){let a;if(testCases.recordIni)for(let b=0,c=testCases.testCase.length;b<c&&b<pm.info.iterationCount;b++)if(pmat.util.setValueObj(testCases,"testCase."+b+".value.output",{}),pmat.util.setValueObj(testCases,"testCase."+b+".value.testConditions",{}),a="testCase_"+testCases.testCase[b].id,!pmat.engine.pmEnvironmentSetJSON(a,testCases.testCase[b].value))throw{name:"pmatSaveError",message:"Tried to save in environment but failed while stringifying... could not save. "+a+": "+testCases.testCase[b].value}},newIteration:function(){if(!testCases||!testCases.testCase||!testCases.hasOwnProperty("iteration"))throw new Error("Error: testCases should have been set up as part of the initialization in newRun...");pmat.engine.incrementTestCasesIndex(),testCases.iteration!==pm.info.iteration&&(console.log("Warning: postman iteration number: "+pm.info.iteration+" and internal iteration number are decoupled: "+testCases.index),console.log("Warning: pmat.api.loader is usually executed once per request!!!")),testCases.testCase[testCases.index]&&testCases.testCase[testCases.index].hasOwnProperty("value")&&testCases.testCase[testCases.index].value.hasOwnProperty("input")?pmat.engine.setIterationVars(testCases.testCase[testCases.index].value.input):console.log("There are not Input variables to setup for index: "+testCases.index+" in iteration: "+pm.info.iteration)},getValidTestCases:function(){if(testCases=pm.variables.get("testCases"),!testCases)throw{name:"pmatFlowStateError",message:"testCases should have been saved as part of the initialization in newRun..."}},incrementTestCasesIndex:function(){if(testCases.iteration++,!testCases||!testCases.testCase||!testCases.hasOwnProperty("iteration"))throw new Error("Error: testCases should have been set up as part of the initialization in newRun...");testCases.record||testCases.recordIni?0===testCases.initialElems?testCases.index=testCases.iteration:testCases.index=testCases.iteration%testCases.initialElems:testCases.testCase.length?testCases.index=testCases.iteration%testCases.initialElems:(console.log("Warning: There are not testcases to test or to record... not much will be done"),testCases.index=-1)},setIterationVarsDoc:"having a testCase Input object it sets up environment variables to run iteration",setIterationVars:function(a){for(let b in a)pmat.engine.pmEnvironmentSetJSON(b,a[b])||console.log("Problems parsing: "+b)},save:function({varName:a=null,valueResponsePath:b=null,value:c=null,requestName:f=null}={}){let g,h,l,m={};if(m.status=1,m.errorMsg="Variable was saved Sucessfully",null===a)return m.status=-1,m.errorMsg="varName is a mandatory field to the function",m;if(null!==b&&null!==c)return m.status=-2,m.errorMsg="valueResponsePath and value cannot specified together. Just 1 valriable is mandatory",m;if(null!==b&&null!==c||null===b&&null===c)return m.status=-3,m.errorMsg="valueResponsePath or value is required.One and only One of them is required.",m;if(null!==f&&f!==pm.info.requestName)return m.status=2,m.errorMsg="save not apply in the current request: "+pm.info.requestName+" vs.: "+f,m;if(null!==c)l=c;else{try{g=pm.response.json()}catch(n){throw console.log(n),n}if(l=pmat.util.getValueObj(g,b),null===l)return m.status=3,m.errorMsg="value was not found using input path in the response of the request. So it was not saved.",m}if(!testCases||void 0===testCases.index||-1===testCases.index)throw console.log("testCases before: Save without testCases definitions is only possible in record* mode",testCases),{name:"pmatSaveError",message:"Save without testCases definitions is only possible in record* mode"};return pmat.engine.setTestCaseInputVar(a,l),h="testCase_"+testCases.testCase[testCases.index].id,pmat.engine.pmEnvironmentSetJSON(h,testCases.testCase[testCases.index].value)||console.log("Problems parsing: "+h),m},setTestCaseInputVar:function(a,b){let c="testCase."+testCases.index+".value.input."+a,f=pmat.util.setValueObj(testCases,c,b);testCases.testCase[testCases.index].hasOwnProperty("id")||(testCases.testCase[testCases.index].id=testCases.index)},record:function(){if(testCases.record||testCases.recordIni){null===pmat.util.getValueObj(testCases,"testCase."+testCases.index+".id")&&pmat.util.setValueObj(testCases,"testCase."+testCases.index+".id",testCases.index);let a="testCase."+testCases.index+".value",b=a+".testConditions."+pm.info.requestName+".expectedResponse",c=pmat.util.getValueObj(testCases,b),f=!0,g=!1,h=!1;null===c?(f=!0,g=!0,h=!1):c.hasOwnProperty(pm.response.code)?(f=!0,g=!1,h=!1):(f=!1,g=!1,h=!0);let k,l;if(null!==c)if(k=pmat.util.objPropsToArray(c),k&&1===k.length)l=k[0];else throw{name:"pmatCorruptedTC",message:"testCases.TestCase[{index}].testConditions.{requestName}.expectedResponse should always have one and only one status"};h&&pm.test("Record-test testCase_"+testCases.testCase[testCases.index].id+" expected Response vs Actual request Response code",function(){pm.expect(pm.response.to.have.statusCode(l))}),g&&pm.test.skip("Record-test testCase_"+testCases.testCase[testCases.index].id+" New TestCase. No test could be done",function(){}),!f||h||g||(console.log("test in recording",l,typeof l),pm.test("Record-test testCase_"+testCases.testCase[testCases.index].id+" validation on the existing condition",function(){pm.expect(pm.response.to.have.statusCode(l))})),f&&(pmat.util.setValueObj(testCases,a+".output."+pm.info.requestName+".status",pm.response.code.toString()),pmat.util.setValueObj(testCases,a+".output."+pm.info.requestName+".responseBody",pm.response.json()));let m,n;m=pmat.util.getValueObj(testCases,"delegateList"),n=!!m&&m.includes(pm.info.requestName);let p=a+".testConditions."+pm.info.requestName+".expectedResponse."+pm.response.code+".delegate";pmat.util.setValueObj(testCases,p,n);let q=a+".testConditions."+pm.info.requestName+".expectedResponse."+pm.response.code+".excludeResponseBodyNodes";_.isArray(pmat.util.getValueObj(testCases,q))||pmat.util.setValueObj(testCases,q,[""]);let r=a+".testConditions."+pm.info.requestName+".expectedResponse."+pm.response.code+".testDescOK";"string"!=typeof pmat.util.getValueObj(testCases,r)&&pmat.util.setValueObj(testCases,r,"Add something...");let s="testConditions."+pm.info.requestName+".expectedResponse."+pm.response.code+".excludeResponseBodyNodes";_.isArray(pmat.util.getValueObj(testCases,s))||pmat.util.setValueObj(testCases,s,[""]);let t="testCase_"+testCases.testCase[testCases.index].id,u="testConditions."+pm.info.requestName+".expectedResponse."+pm.response.code+".testDescOK";"string"!=typeof pmat.util.getValueObj(testCases,u)&&pmat.util.setValueObj(testCases,u,"Add something...!!!"),pmat.engine.pmEnvironmentSetJSON(t,testCases.testCase[testCases.index].value)||console.log("Problems parsing: "+t),pmat.engine.pmEnvironmentSetJSON("testConditions",testCases.testConditions)||console.log("Problems parsing: testConditions")}},test:function(){let a,b,c,f,g,h;return a="testCase."+testCases.index+".value.testConditions."+pm.info.requestName+".expectedResponse",b=pmat.util.getValueObj(testCases,a),c=pmat.util.getValueObj(testCases,"testConditions."+pm.info.requestName+".expectedResponse"),f="testCase."+testCases.index+".value.output."+pm.info.requestName+".responseBody",g=pmat.util.getValueObj(testCases,f),null===g||null===b?void pm.test("A previous record creates an Ouput and expected Output to be used in test mode",function(){pm.expect(g).to.not.equal(null),pm.expect(b).to.not.equal(null)}):void(pmat.util.getValueObj(b,pm.response.code.toString()+".delegate")?null!==c&&(h="testConditions",pmat.engine.toTest(c,g,h)):(h="testCase_"+testCases.testCase[testCases.index].id,pmat.engine.toTest(b,g,h)),console.log("end of test..."))},toTest:function(a,b,c){let g,h,k,l,f=[];if(null!==a){f=pmat.util.objPropsToArray(a),g=pmat.util.getValueObj(a,pm.response.code.toString());let m;m=null!==g&&g.testDescOK?g.testDescOK:"Description doesnt exist",pm.test(c+": Validating Response code. "+m,function(){pm.expect(pm.response.code.toString()).to.be.oneOf(f)}),h=g.excludeResponseBodyNodes,void 0==h?k=_.isEqualWith(b,l):(h.constructor!==Array&&(h[0]=h),l=pm.response.json(),k=pmat.engine.compare(b,l,h,void 0)),k?console.log("TEST OK :-)"):console.log("TEST FAILED!!! response doesnt match expected result",JSON.stringify(b),JSON.stringify(l)),pm.test(c+": Validating Response body. "+m,function(){k||pm.expect("Excluded nodes: "+h+" Stored: "+JSON.stringify(b)).to.be.equal("Obtained: "+JSON.stringify(l))})}},assert:function(...a){},pathToRegexDoc:"Converts path search into regular expression",pathToRegex:function(...a){let b,c=[];for(let f=0,g=a.length;f<g;f++)b=a[f].split(".").join("[.]"),b=b.split("*").join("[^.]*"),b=b.split("[^.]*[^.]*").join(".*"),b="^"+b+"$",c[f]=new RegExp(b);return c},testRegexsORDoc:"Converts path search into regular expression",testRegexsOR:function(a,...b){let c,f;for(c=0,f=b.length;c<f&&!b[c].test(a);c++);return c!==f},removeNodesDoc:"1st param: Json Object\n2nd param: array of regularExpr to match paths to exclude. Main object represented by: root.\n3rd param: function that if true allows the omitt to do its work. In this case we ommit\n           only values that are end-nodes.",removeNodes:function(a,b,c){function f(h,k,l){let m;for(let n in h)m=""===g?n:g+"."+n,pmat.engine.testRegexsOR(m,...k)&&(l?l(h[n])&&_.unset(h,n):_.unset(h,n)),"object"==typeof h[n]&&(g=m,f(h[n],k,l),g=g.split("."),g?g.pop():console.log("It got to null"),g=g.join("."))}let g="";f(a,b,c)},compare:function(a,b,c,f){let g,h;return g=pmat.engine.pathToRegex(...c),pmat.engine.removeNodes(a,g,f),pmat.engine.removeNodes(b,g,f),h=_.isEqualWith(a,b),h},pmEnvironmentGetJSON:function(a){let b=pm.environment.get(a);if(b!==void 0)try{return JSON.parse(b)}catch(c){return b}else return b},pmGlobalsGetJSON:function(a){let b=pm.globals.get(a);if(b!==void 0)try{return JSON.parse(b)}catch(c){return b}else return b},pmEnvironmentSetJSON:function(a,b){let c;try{if(c="string"==typeof b?b:JSON.stringify(b),!pm.environment.values.toJSON().length)throw{name:"pmatSaveError",message:"Tried to save in environment but no environment was selected:... could not save. "+a+": "+c};else pm.environment.set(a,c);return!0}catch(f){if("pmatSaveError"===f.name)throw f;else return console.log("problem stringifying... stringify result: "+c),!1}},pmGlobalsSetJSON:function(a,b){let c;try{return c="string"==typeof b?b:JSON.stringify(b),pm.globals.set(a,c),!0}catch(f){return console.log("Error in pmGlobalsSetJSON"),!1}},splitInTwoFindPrefixes:function(a,...b){let c,f=[];return c=_.findIndex(b,function(g){return 0===a.indexOf(g)}),-1!==c&&(f[0]=b[c],f[1]=a.substring(b[c].length)),f}}};try{pmat.api.loader()}catch(a){console.log("failed to execute pmat.api.loader: exception name: "+a.name+" message: "+a.message),pm.test("Critital ERROR!!!! There have been exceptions... take a look to the console logs to see them...",function(){pm.expect(0).to.equal(1)})}
